<html>
  <head>
    <meta name="readthedocs-project-slug" content="project" />
    <meta name="readthedocs-version-slug" content="version" />
  </head>
  <body>
    <script type="module">
      import { default as sinon } from "sinon";
      import { expect, elementUpdated } from "@open-wc/testing";
      import { runTests } from "@web/test-runner-mocha";
      import * as readthedocsConfig from "../src/readthedocs-config";
      import * as utils from "../src/utils";

      let server;
      let metadataAddonsAPIVersion;
      let metadataProject;
      let metadataVersion;

      runTests(async () => {
        beforeEach(() => {
          // Create a sinon fake server to mock requests
          server = sinon.fakeServer.create();
          server.respondImmediately = true;

          if (metadataAddonsAPIVersion) {
            metadataAddonsAPIVersion.remove();
          }
        });

        afterEach(() => {
          // Restore the fake server to its original state
          server.restore();
        });

        describe("Read the Docs config", () => {
          it("test API url without ?url= param", async () => {
            let url;

            url = readthedocsConfig._getApiUrl(false, 1);
            expect(url).to.be.equal(
              `/_/addons/?client-version=${utils.CLIENT_VERSION}&api-version=1&project-slug=project&version-slug=version`,
            );

            url = readthedocsConfig._getApiUrl(false, 2);
            expect(url).to.be.equal(
              `/_/addons/?client-version=${utils.CLIENT_VERSION}&api-version=2&project-slug=project&version-slug=version`,
            );
          });

          it("test API url with ?url= param", async () => {
            const url = readthedocsConfig._getApiUrl(true, 1);
            expect(url).to.match(
              /^\/_\/addons\/\?client-version=.+&api-version=1&url=.+$/,
            );
          });

          it("fetch config from API endpoint", async () => {
            const matchMockedUrl = new RegExp(`^/_/addons/`, "g");
            server.respondWith("GET", matchMockedUrl, [200, {}, "{}"]);

            const config = readthedocsConfig.getReadTheDocsConfig(false);

            expect(server.requests).to.have.length(1);
            expect(server.requests[0].status).to.be.equal(200);
            expect(server.requests[0].method).to.be.equal("GET");
            const apiUrl = `/_/addons/?client-version=${utils.CLIENT_VERSION}&api-version=1&project-slug=project&version-slug=version`;
            expect(server.requests[0].url).to.be.equal(apiUrl);
          });

          it("fetch config from API endpoint for user", async () => {
            metadataAddonsAPIVersion = document.createElement("meta");
            metadataAddonsAPIVersion.name = "readthedocs-addons-api-version";
            metadataAddonsAPIVersion.content = "2";
            document.head.appendChild(metadataAddonsAPIVersion);

            // Response 200 on requests made to Read the Docs analytics' API
            const matchMockedUrl = new RegExp(`^/_/addons/`, "g");
            server.respondWith("GET", matchMockedUrl, [
              200,
              {},
              '{"addons": {}, "builds": {"current": {"id": 12345}}, "projects": {}, "versions": {}}',
            ]);

            const config =
              await readthedocsConfig.getReadTheDocsUserConfig(true);
            expect(config).to.deep.equal({
              addons: {},
              builds: { current: { id: 12345 } },
              projects: {},
              versions: {},
            });

            expect(server.requests).to.have.length(1);
            expect(server.requests[0].status).to.be.equal(200);
            expect(server.requests[0].method).to.be.equal("GET");
            const matchApiUrl =
              /^\/_\/addons\/\?client-version=.+&api-version=2&url=.+$/;
            expect(server.requests[0].url).to.match(matchApiUrl);
          });

          it("check readthedocs-addons-data-ready event", async () => {
            // Response 200 on requests made to Read the Docs analytics' API
            const matchMockedUrl = new RegExp(`^/_/addons/`, "g");
            server.respondWith("GET", matchMockedUrl, [
              200,
              {},
              '{"test": "readthedocs-addons-data-ready", "builds": {"current": {"id": 12345}}}',
            ]);

            const fakeFunction = sinon.fake();
            document.addEventListener(
              "readthedocs-addons-data-ready",
              (event) => {
                // Call the `fakeFunction` inside the event listener to check later it was called once.
                fakeFunction();
              },
            );

            const config = await readthedocsConfig.getReadTheDocsConfig(true);

            expect(fakeFunction.calledOnce).to.be.true;
            const element = document.querySelector("#injected-by-event");
            expect(element).to.not.be.null;
            expect(element).dom.to.be.equal(
              "<span id='injected-by-event'>builds.current.id=12345</span>",
            );

            // Clean up injected tags
            element.remove();
          });
        });
      });
    </script>

    <!-- TODO: this should only be injected in the test "check readthedocs-addons-data-ready event",
         to not interfere with the other tests, but I didn't find a good way to do that yet. -->
    <script id="script-event" type="text/javascript">
      document.addEventListener(
        "readthedocs-addons-data-ready",
        function (event) {
          const data = event.detail.data(true);
          if (data?.test === "readthedocs-addons-data-ready") {
            const span = document.createElement("span");
            span.id = "injected-by-event";
            span.innerHTML = `builds.current.id=${data.builds.current.id}`;
            document.body.appendChild(span);
          }
        },
      );
    </script>
    `;
  </body>
</html>
